References:   "Gemini"

"https://web.dev"

ðŸš¨ All of these teachings are based off the Google Web.Dev Page. However, I am being constantly attacked on this Page, seeing DOS attacks. My suggestion LinkedIn Learning over anything Google. Why?? For your Protection.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           â€¢â€¢â€¢Arraysâ€¢â€¢â€¢
1. To create a Array in jS, remember we must use [].

ðŸ”¹ðŸ”¹Example1-Create:
const myArray = [];


ðŸ”¹ðŸ”¹Example2-New:
const myArray = new Array();


ðŸ”¹ðŸ”¹Example3-String:
const myArray = [ true, null, "String", false ];

myArray;
> [ true, null, "String", false ]

2. Array literals inherit their properties && methods from the corresponding constructor.

ðŸ”¹ðŸ”¹Example2-ArrayLiteral:
const arrayLiteral = [];
const arrayConstructor = new Array();

typeof arrayLiteral;
> "object"

arrayLiteral;
> Array []
    length: 0
    <prototype>: Array []

typeof arrayConstructor;
> "object"

arrayConstructor;
> Array []
    length: 0
    <prototype>: Array []
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        â€¢â€¢â€¢Sparse Arraysâ€¢â€¢â€¢

1. A sparse array is an array in which most of the elements have the same value (typically zero), meaning that only a small number of elements hold meaningful data.

ðŸ”¹ðŸ”¹Example1-SparseArray:
Consider a 10x10 array representing a game board, where most cells are empty (represented by 0) and only a few contain game pieces (represented by other numbers).
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

In this example, only two elements (the '1' and the '2') are non-zero, while the rest are zero. Storing all 100 elements would be inefficient if most are empty. Sparse array data structures (like hash maps or linked lists of non-zero elements) are used to store only the non-zero values and their positions, saving memory and processing time.


ðŸ”¹ðŸ”¹Example2-EmptySlot:
const myArray = [ 1,, 3, 4 ];

myArray.length;
> 4

for( const myValue of myArray ) {
  console.log( myValue + 10 );
}
> 11
> NaN
> 13
> 14
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     â€¢â€¢â€¢Accessing Arraysâ€¢â€¢â€¢

ðŸ”¹ðŸ”¹Example1:
// 1. Declaring an array
const fruits = ["Apple", "Banana", "Cherry", "Date", "Elderberry"];
const numbers = [10, 20, 30, 40, 50];
const mixedData = ["Hello", 123, true, null, { key: "value" }];

console.log("--- Accessing elements from the 'fruits' array ---");

// 2. Accessing elements using index (0-based)
console.log("First fruit:", fruits[0]);    // Output: Apple
console.log("Second fruit:", fruits[1]);   // Output: Banana
console.log("Third fruit:", fruits[2]);    // Output: Cherry

// 3. Accessing the last element
console.log("Last fruit:", fruits[fruits.length - 1]); // Output: Elderberry

console.log("\n--- Accessing elements from the 'numbers' array ---");

// 4. Accessing elements from 'numbers' array
console.log("First number:", numbers[0]);  // Output: 10
console.log("Fourth number:", numbers[3]); // Output: 40

console.log("\n--- Accessing elements from the 'mixedData' array ---");

// 5. Accessing elements from 'mixedData' array
console.log("First element (string):", mixedData[0]);      // Output: Hello
console.log("Second element (number):", mixedData[1]);     // Output: 123
console.log("Third element (boolean):", mixedData[2]);     // Output: true
console.log("Fifth element (object):", mixedData[4]);      // Output: { key: 'value' }
console.log("Accessing a property of the object in the array:", mixedData[4].key); // Output: value

// 6. What happens if you try to access an index out of bounds?
console.log("\n--- Out of Bounds Access ---");
console.log("Trying to access index 10 in 'fruits':", fruits[10]); // Output: undefined
console.log("Trying to access negative index:", fruits[-1]); // Output: undefined (JavaScript doesn't support negative indexing directly for arrays)

// 7. Using a loop to access all elements
console.log("\n--- Using a loop to access all fruits ---");
for (let i = 0; i < fruits.length; i++) {
  console.log(`Fruit at index ${i}: ${fruits[i]}`);
}

console.log("\n--- Using forEach to access all numbers ---");
numbers.forEach(function(number, index) {
  console.log(`Number at index ${index}: ${number}`);
});

console.log("\n--- Using for...of loop to access all mixedData elements ---");
let index = 0;
for (const item of mixedData) {
  console.log(`Element at index ${index}: ${item}`);
  index++;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  â€¢â€¢â€¢Destructing Assignmentsâ€¢â€¢â€¢

1. "Binding Pattern Destruction" occurs when each value is unpacked from the array or object. Then is  assigned to the corresponding variable. 


2. We can use both curly braces ({}) to destructure an object. Then we can use square brackets ([]) to destructure the arrays.

ðŸ”¹ðŸ”¹Example1:

const myArray = [ "A string", "A second string" ];
const [ myFirstElement, mySecondElement ] = myArray;

const myObject = { firstValue: false, secondValue: true };
const { myProp, mySecondProp } = myObject;

myFirstElement;
> "My string"

mySecondElement;
> "Second string"

myProp;
> false

mySecondProp;
> true



ðŸ”¹ðŸ”¹Example2-DestructingArrays:
// 1. Basic Array Destructuring
console.log("--- Basic Array Destructuring ---");
const colors = ["red", "green", "blue", "yellow"];

// Destructure the first three elements into distinct variables
const [firstColor, secondColor, thirdColor] = colors;

console.log(firstColor);  // Output: red
console.log(secondColor); // Output: green
console.log(thirdColor);  // Output: blue

// 2. Skipping Elements
console.log("\n--- Skipping Elements ---");
const fruits = ["apple", "banana", "cherry", "date"];

// Skip the second element by leaving an empty space
const [fruit1, , fruit3] = fruits;

console.log(fruit1); // Output: apple
console.log(fruit3); // Output: cherry

// 3. Rest Parameter (Gathering Remaining Elements)
console.log("\n--- Rest Parameter ---");
const numbers = [10, 20, 30, 40, 50, 60];

// Get the first two numbers and put the rest into a new array
const [num1, num2, ...remainingNumbers] = numbers;

console.log(num1);            // Output: 10
console.log(num2);            // Output: 20
console.log(remainingNumbers); // Output: [30, 40, 50, 60]

// 4. Default Values
console.log("\n--- Default Values ---");
const developers = ["Alice", "Bob"];

// If an element is undefined in the array, a default value can be used
const [dev1, dev2, dev3 = "Charlie"] = developers;

console.log(dev1); // Output: Alice
console.log(dev2); // Output: Bob
console.log(dev3); // Output: Charlie (because developers[2] is undefined)

const emptyArray = [];
const [a = 1, b = 2] = emptyArray;
console.log(a); // Output: 1
console.log(b); // Output: 2

// 5. Swapping Variables (without a temporary variable)
console.log("\n--- Swapping Variables ---");
let x = 5;
let y = 10;

console.log(`Before swap: x = ${x}, y = ${y}`); // Output: Before swap: x = 5, y = 10

[x, y] = [y, x]; // Swap them!

console.log(`After swap: x = ${x}, y = ${y}`);  // Output: After swap: x = 10, y = 5

// 6. Destructuring with Functions (returning an array)
console.log("\n--- Destructuring with Functions ---");

function getUserInfo() {
  return ["John Doe", 30, "Software Engineer"];
}

const [name, age, occupation] = getUserInfo();

console.log(`Name: ${name}, Age: ${age}, Occupation: ${occupation}`);
// Output: Name: John Doe, Age: 30, Occupation: Software Engineer

// 7. Nested Array Destructuring (less common but possible)
console.log("\n--- Nested Array Destructuring ---");
const coordinates = [10, [20, 30], 40];

const [coord1, [nestedCoord1, nestedCoord2], coord3] = coordinates;

console.log(coord1);      // Output: 10
console.log(nestedCoord1); // Output: 20
console.log(nestedCoord2); // Output: 30
console.log(coord3);      // Output: 40
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. In this example we demonstrate the difference in using [] for objects && {} for arrays.

2. When we destruct an array, the format consists of a sequential order. Which is left to right.

ðŸ”¹ðŸ”¹Example2-[}
const myArray = [ false, true ];
const myObject = { firstValue: false, secondValue: true };

const [ myProp, mySecondProp ] = myObject;
> Uncaught TypeError: myObject is not iterable

const { myElement, mySecondElement } = myArray;

myElement
> undefined

mySecondElement;
> undefined




ðŸ”¹ðŸ”¹Example3-Order:

const myArray = [ 1, 2, 3 ];
const [ myElement, mySecondElement, myThirdElement ] = myArray;

myElement;
> 1

mySecondElement;
> 2

myThirdElement;
> 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       â€¢â€¢â€¢Spread Arrayâ€¢â€¢â€¢
1. The Spread Syntax was designed to copy and combine arrays.

ðŸ”¹ðŸ”¹Example1-Spread:

const myArray = [ 1, 2, 3 ];
const spreadArray = [ ...myArray ];

spreadArray;
> Array(3) [ 1, 2, 3 ]




2. In this example we will be merging an array.

ðŸ”¹ðŸ”¹Example2-Merge:
const myArray = [ 1, 2, 3 ];
const mySecondArray = [ 4, 5, 6 ];
const myNewArray = [ ...myArray, ...mySecondArray ];

myNewArray;
> Array(6) [ 1, 2, 3, 4, 5, 6 ]




3. In this example we will be passing the elements.

ðŸ”¹ðŸ”¹Example3-Passing:

const myArray = [ true, false ];
const myFunction = ( myArgument, mySecondArgument ) => {
    console.log( myArgument, mySecondArgument );
};

myFunction( ...myArray );
> true false



4. The Spread array also will work with a "Object Literal".

ðŸ”¹ðŸ”¹Example4-Duplicate:
const myObj = { myProperty : true };
const mySecondObj = { ...myObj };

mySecondObj;
> Object { myProperty: true }


ðŸ”¹ðŸ”¹Example5-Merge:
const myFirstObj = { myProperty : true };
const mySecondObj = { additionalProperty : true };
const myMergedObj = { ...myFirstObj, ...mySecondObj };

myMergedObj;
> Object { myProperty: true, additionalProperty: true }