°°° FORMS °°°

Resources: 

"https://web.dev/learn/forms/validation"

"https://web.dev/learn/forms/validation"

"https://web.dev/learn/forms/design-basics"

"https://developer.mozilla.org/docs/Web/HTML/Element/Input#input_types"

"https://soloist.ai/dailyinvestors"

"https://web.dev/learn/html/dialog"

"https://web.dev/learn/forms"

"https://web.dev/learn/html/forms#built-in_validation"

~~~      ~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° The HTML "<form>" element identifies documents containing interactive controls for submitting information. Stored inside the <form> tag,  you will find all the interactive controls for that "<form>" °°°

°°° When using <form> you can validate the information entered, and submit the data to a server. °°°
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Validations °°°

°°° All the different form control values van go through client-side constraint validation. This can prevent submissions until the data matches the required criteria. °°°

°°° You can also turn this feature off by setting the "novalidate" attribute on the <form>. °°°

°°° The "formnovalidate" on a button, can save the form data for later completion, prevents validation. Basically a Persistenence of sorts. °°°

°°° Example Client-Side DOM Sanitizer, called: "DomPurify":
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML and JavaScript Sanitizer Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    </head>
<body>
    <h1>User Comment Section</h1>
    <textarea id="user-input" rows="10" cols="50">
<img src="x" onerror="alert('XSS Attack!');">
<p>Hello <script>alert('Evil script!');</script> world!</p>
<a href="javascript:alert('Another XSS!');">Click me</a>
<div onmouseover="alert('Mouse over XSS!')">Hover here</div>
<b>This is safe bold text.</b>
    </textarea>
    <button onclick="displaySanitizedContent()">Display Sanitized Content</button>

    <h2>Sanitized Output:</h2>
    <div id="output"></div>

    <script>
        function displaySanitizedContent() {
            const userInput = document.getElementById('user-input').value;

            // DOMPurify.sanitize() will remove potentially dangerous HTML and JavaScript.
            // By default, it allows a safe subset of HTML tags and attributes.
            const cleanHTML = DOMPurify.sanitize(userInput);

            document.getElementById('output').innerHTML = cleanHTML;

            console.log('Original Input:', userInput);
            console.log('Sanitized Output:', cleanHTML);
        }
    </script>
</body>
</html>

°°° JavaScript Sanitizer for Client-Side :
// 1. Create a new <div> element
const container = document.createElement('div');
container.id = 'myContainer'; // 

Give it an ID
container.style.border = '2px solid blue'; // Add some style
container.style.padding = '10px';
container.style.margin = '20px';
console.log('Created container:', container);

// 2. Create a heading and append it to the container
const heading = document.createElement('h2');
heading.textContent = 'My Dynamic List'; // Set its text content
container.appendChild(heading); // Add the heading to the container
console.log('Added heading to container.');

// 3. Create an unordered list (ul)
const ul = document.createElement('ul');
ul.style.listStyleType = 'disc'; // Set list style
ul.style.marginLeft = '20px';
console.log('Created unordered list.');

// 4. Define some list items
const items = ['Item One', 'Item Two', 'Item Three', 'Item Four'];

// 5. Loop through items and create <li> elements
items.forEach((text, index) => {
    const li = document.createElement('li'); // Create a list item
    li.textContent = `${text} (Index: ${index})`; // Set its text
    li.style.color = index % 2 === 0 ? 'green' : 'purple'; // Style based on index
    ul.appendChild(li); // Append list item to the unordered list
});
console.log('Added list items to UL.');

// 6. Append the unordered list to the container
container.appendChild(ul);
console.log('Added UL to container.');

// 7. Append the entire container to the <body> of the document
document.body.appendChild(container);
console.log('Container appended to body! Check the page.');

// --- You can also add interactivity ---
// 8. Create a button
const button = document.createElement('button');
button.textContent = 'Add New Item';
button.style.marginTop = '10px';
container.appendChild(button); // Append button to container
console.log('Added button.');

// 9. Add an event listener to the button
let newItemCount = 0;
button.addEventListener('click', () => {
    newItemCount++;
    const newLi = document.createElement('li');
    newLi.textContent = `New Dynamic Item ${newItemCount}`;
    newLi.style.fontWeight = 'bold';
    newLi.style.color = 'red';
    ul.appendChild(newLi); // Add new item to the existing list
    console.log(`Added "New Dynamic Item ${newItemCount}"`);
});
console.log('Added click event listener to button.');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Submit Button °°°
<input type="submit" value="Submit Form">
<button type="submit">Submit Form</button>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° The <form> element's action and method attribute values define the URL that processes the form data. °°°

°°° Using the form attribute, it is also possible to include "form controls" outside the "<form>" and to omit form controls stored inside the <form>°°°

°°° When using "<form>" attributes you can also disassociate controls by leaving it empty or a space.°°°

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Methods °°°
°°°The "method" attribute defines the HTTP protocol of the request. Normally  GET or POST. °°°

°°° Commonly Used Methods°°°
 * GET
 * HEAD
 * POST
 * PUT
 * DELETE
 * CONNECT
 * OPTIONS
 * TRACE
 * PATCH
 * PROPFIND (WebDAV)
 * PROPPATCH (WebDAV)
 * MKCOL (WebDAV)
 * COPY (WebDAV)
 * MOVE (WebDAV)
 * LOCK (WebDAV)
 * UNLOCK (WebDAV)
 * REPORT (WebDAV)
 * MKACTIVITY (WebDAV)
 * CHECKOUT (WebDAV)
 * MERGE (WebDAV)
 * M-SEARCH (UPnP)
 * NOTIFY (UPnP)
 * SUBSCRIBE (UPnP)
 * UNSUBSCRIBE (UPnP)
 * SEARCH (RFC 5323)
 * PROPFIND
 * PROPPATCH
 * LOCK
 * MERGE
 * M-SEARCH
 * NOTIFY
 * SUBSCRIBE
 * UNSUBSCRIBE
 * SEARCH
 * ACL
 * BASELINE-CONTROL
 * BIND
 * CHECKIN
 * LABEL
 * LINK
 * MKCALENDAR
 * MKREDIRECTREF
 * MKWORKSPACE
 * ORDERPATCH
 * PRI
 * REBIND
 * UNBIND
 * UNCHECKOUT
 * UNLINK
 * UPDATE
 * UPDATEREDIRECTREF
 * VERSION-CONTROL
 * Dialog

°°°Note: There may be more methods, guaranteed. However this is a quick  resourceful example created by Gemini.°°°

°°°With "GET" the form data is sent as a (parameter string) of name=value pairs, that are appended to the action's URL.°°°

°°° With "POST" the data is appended to the body of the HTTP request. This is more secure to send your personal data.°°°

°°°There is also a "DIALOG method".  <form method="dialog"> 
 Submitting this form will close the dialog, if submitted inside a dialog. °°°
include both the formmethod="dialog"
and 
"formnovalidate"
on the submit button, to ensure everything GETs submitted.°°°

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Form Buttons🔘 °°°
Form buttons can have more than the attributes. If a button includes  { formaction, formenctype, formmethod, formnovalidate, or formtarget attribute }, there set values for that button takes precedence over the action, enctype, method, and target!

°°°Note: Remember to give the Button a Name, this way you can keep track of it.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Results of a Submitted Form°°°

<form method="GET">
  <label for="student">Pick a student:</label>
  <select name="student" id="student">
    <option value="hoover">Hoover Sukhdeep</option>
    <option>Blendan Smooth</option>
    <option value="crispy">Crispy Doughnuts</option>
  </select>
  <input type="submit" value="Submit Form">
</form>

°°° How the URLS look upon Submission:
https://web.dev/learn/html/forms?student=hoover #Using only Hover°°

https://web.dev/learn/html/forms?student=Blendan+Smooth # With Blendan Smooth°°°
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° For "<input>" elements  where the users can't edit the value. It is recommended to always include a value! °°°
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Radio Buttons °°°°
 

function getSelectedColor() {
    const colorRadioButtons = document.querySelectorAll('input[name="favorite_color"]');
    let selectedValue = '';

    for (const radioButton of colorRadioButtons) {
        if (radioButton.checked) {
            selectedValue = radioButton.value;
            break; // Exit the loop once the checked radio button is found
        }
    }

    const displayParagraph = document.getElementById('selectedColorDisplay');
    if (selectedValue) {
        displayParagraph.textContent = 'You selected: ' + selectedValue;
    } else {
        displayParagraph.textContent = 'No color selected.';
    }
}


🚨 Note: 
 ° Always specify the type attribute ("submit", "button", or "reset").
  • Why it's important: This is crucial for defining the button's behavior, especially within a <form>.
     ° type="submit" (default): This button will submit the form data to the server. If you omit the type attribute within a form, this is its default behavior.
     ° type="button": This button does nothing by default when clicked. It's used for triggering JavaScript functions without submitting a form. This is the most common type for buttons that interact purely with client-side scripts.
     ° type="reset": This button resets all form fields to their initial values.
   ° Rule: Be explicit. If your button isn't meant to submit a form, always use type="button". This prevents unintended form submissions and makes your code clearer.
 ° Provide clear, concise, and descriptive text content that accurately reflects the button's action.
   ° Why it's important: This is fundamental for user experience and accessibility. Users should be able to understand what happens when they click the button just by reading its text. This also helps screen readers convey meaning to visually impaired users.
   ° Rule: Avoid vague labels like "Click Here" or "Submit." Instead, use action-oriented verbs that describe the outcome, such as "Save Changes," "Add to Cart," "Delete Item," "Get Directions," "Send Message," or "Sign Up."
 ° Use the <button> element for interactive actions, not <a> tags styled as buttons.
   ° Why it's important: The <button> element is semantically designed for triggering actions, whereas <a> (anchor) tags are for navigation (linking to another page or a section within the same page). Using <a> for actions can confuse assistive technologies and create unexpected keyboard navigation behaviors.
   ° Rule: If clicking the element performs an action (e.g., submitting data, opening a modal, playing a video, triggering JavaScript), use <button>. If clicking the element takes the user to a different URL or part of the page, use <a>. Consistent semantic HTML improves accessibility, maintainability, and search engine optimization.
"Gemini"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Check Boxes ✔️ °°°
°Example:
https://web.dev/learn/html/forms?chk=on&chk=on&chk=on

°°Example Code°
function createCheckbox(id, name, value, labelText, parentElement) {
    // Create the input element
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = id;
    checkbox.name = name;
    checkbox.value = value;

    // Create the label element
    const label = document.createElement('label');
    label.htmlFor = id; // Link label to checkbox by ID
    label.textContent = labelText;

    // Append them to the specified parent element
    parentElement.appendChild(checkbox);
    parentElement.appendChild(label);
    parentElement.appendChild(document.createElement('br')); // Optional: for new line
}

// Example Usage:
const container = document.getElementById('checkboxContainer'); // Make sure you have a div with this ID in your HTML

if (container) {
    createCheckbox('option1', 'options', 'value1', 'Option A', container);
    createCheckbox('option2', 'options', 'value2', 'Option B', container);
    createCheckbox('option3', 'options', 'value3', 'Option C', container);
} else {
    console.error("Element with ID 'checkboxContainer' not found.");
}

°°°Apending:
To append elements to the DOM using JavaScript, you generally follow these steps:
 • Select a parent element: Identify an existing element in your HTML document where you want to add the new elements.
 • Create the new elements: Use JavaScript methods like document.createElement() or construct HTML strings.
 • Append the new elements: Use methods like appendChild(), insertBefore(), replaceChild(), or insertAdjacentHTML() to place the newly created elements into the selected parent.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Concept of Appending°°°
The core method for adding an element (childElement) as the last child of another element (parentElement) is:
parentElement.appendChild(childElement);


°°° Appending Dynamically Created Radio Buttons°°°
In the radio button example, the getSelectedColor() and setFavoriteColor() functions were about interacting with existing radio buttons. However, if you wanted to create the radio buttons themselves dynamically, you'd use a similar approach to the checkbox creation.

Let's adapt the checkbox creation method to create radio buttons:

°°°JavaScript:
// Function to create and append a single radio button group

function createRadioButton(id, name, value, labelText, parentElement, isChecked = false) {
    const radioInput = document.createElement('input');
    radioInput.type = 'radio';
    radioInput.id = id;
    radioInput.name = name; // All radios in a group must have the same name
    radioInput.value = value;
    if (isChecked) {
        radioInput.checked = true;
    }

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;

    // Optional: wrap in a div for better layout control
    const divWrapper = document.createElement('div');
    divWrapper.appendChild(radioInput);
    divWrapper.appendChild(label);

    parentElement.appendChild(divWrapper);
}

// Function to append a group of radio buttons
function appendRadioButtonsToDOM() {
    const radioContainer = document.getElementById('radioContainer'); // Get your target container

    if (radioContainer) {
        // Clear previous content (optional, but good for re-rendering)
        radioContainer.innerHTML = '';

        // Create and append radio buttons
        createRadioButton('opt1', 'myChoices', 'choiceA', 'Option A', radioContainer);
        createRadioButton('opt2', 'myChoices', 'choiceB', 'Option B', radioContainer, true); // Initially checked
        createRadioButton('opt3', 'myChoices', 'choiceC', 'Option C', radioContainer);

        // You can also add an event listener to the container and use event delegation
        radioContainer.addEventListener('change', (event) => {
            if (event.target.type === 'radio' && event.target.name === 'myChoices') {
                console.log('Selected radio button:', event.target.value);
                document.getElementById('selectedDynamicRadio').textContent = 'Dynamic Radio Selection: ' + event.target.value;
            }
        });

    } else {
        console.error("Element with ID 'radioContainer' not found.");
    }
}

HTML (where the radio buttons will appear):
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Radio Buttons and Checkboxes</title>
</head>
<body>
    <h1>Dynamic Content</h1>

    <h2>Radio Buttons</h2>
    <button onclick="appendRadioButtonsToDOM()">Load Radio Buttons</button>
    <div id="radioContainer">
        </div>
    <p id="selectedDynamicRadio"></p>

    <hr>

    <h2>Checkboxes</h2>
    <button onclick="appendCheckboxesToDOM()">Load Checkboxes</button>
    <div id="checkboxContainer">
        </div>
    <p id="selectedDynamicCheckboxes"></p>

    <script>
        // Paste the JavaScript functions here or link a separate JS file
        // ... (all radio button and checkbox creation functions from previous responses) ...

        // Example for checkbox appending (from previous response)
        function appendCheckboxesToDOM() {
            const container = document.getElementById('checkboxContainer');
            if (container) {
                container.innerHTML = ''; // Clear previous
                createCheckbox('option1', 'options', 'value1', 'Option A', container);
                createCheckbox('option2', 'options', 'value2', 'Option B', container);
                createCheckbox('option3', 'options', 'value3', 'Option C', container);

                // Add an event listener to the container for checkboxes
                container.addEventListener('change', (event) => {
                    if (event.target.type === 'checkbox' && event.target.name === 'options') {
                        const checkedBoxes = Array.from(document.querySelectorAll('#checkboxContainer input[type="checkbox"][name="options"]:checked'))
                                                  .map(cb => cb.value);
                        document.getElementById('selectedDynamicCheckboxes').textContent = 'Selected Checkboxes: ' + (checkedBoxes.length ? checkedBoxes.join(', ') : 'None');
                    }
                });
            }
        }

        // Call the radio button append function when the page loads, or on button click
        // document.addEventListener('DOMContentLoaded', appendRadioButtonsToDOM); // Uncomment to load on page load
    </script>
</body>
</html>

°°° Appending Dynamically Created Checkboxes°°°

°°°From the previous answer, here's how the different methods appended elements:
 • createCheckbox() (Method 1): Directly used parentElement.appendChild(checkbox); and parentElement.appendChild(label); inside the function.
   function createCheckbox(id, name, value, labelText, parentElement) {
    // ... create checkbox and label elements ...
    parentElement.appendChild(checkbox);
    parentElement.appendChild(label);
    parentElement.appendChild(document.createElement('br')); // Optional: for new line
}
// Usage:
// const container = document.getElementById('checkboxContainer');
// createCheckbox('option1', 'options', 'value1', 'Option A', container);

 ••• createCheckboxElements() 

°°°(Method 2): Returned an object containing the elements, and then you appended the wrapper outside the function. This gives you more 
control.°°°


   function createCheckboxElements(id, name, value, labelText) {
    // ... create checkbox, label, and wrapper elements ...
    return { checkbox, label, wrapper };
}
// Usage:
// const container2 = document.getElementById('checkboxContainer2');
// const cb1 = createCheckboxElements('itemA', 'items', 'apple', 'Apple');
// container2.appendChild(cb1.wrapper); // Appending the wrapper

 • createCheckboxUsingTemplate() (Method 3): Used insertAdjacentHTML('beforeend', htmlString); to parse an HTML string and insert it.
   function createCheckboxUsingTemplate(id, name, value, labelText, parentElement, isChecked = false) {
    const checkedAttr = isChecked ? 'checked' : '';
    const htmlString = `
        <div>
            <input type="checkbox" id="${id}" name="${name}" value="${value}" ${checkedAttr}>
            <label for="${id}">${labelText}</label>
        </div>
    `;
    parentElement.insertAdjacentHTML('beforeend', htmlString);
}
// Usage:
// const container3 = document.getElementById('checkboxContainer3');
// createCheckboxUsingTemplate('task1', 'tasks', 'buy_milk', 'Buy Milk', container3);

°°°Summary of Appending Methods°°°
  •••parentElement.appendChild(childElement): Appends a node as the last child of a parent node. This is the most common and generally recommended method for appending single DOM nodes.
  •••parentElement.insertBefore(newNode, referenceNode): Inserts newNode before referenceNode as a child of parentElement. If referenceNode is null, it acts like appendChild.
  °°°parentElement.replaceChild(newChild, oldChild): Replaces an oldChild with a newChild within the parentElement.
  °°°parentElement.insertAdjacentElement(position, element): Inserts an element relative to the parentElement at specified position (e.g., 'beforebegin', 'afterbegin', 'beforeend', 'afterend').
  °°°parentElement.insertAdjacentHTML(position, htmlString): Parses an htmlString and inserts the resulting nodes into the DOM tree relative to the parentElement at specified position. Use with caution for user-generated content due to XSS risks.
 
°°° parentElement.innerHTML = htmlString: Replaces all the content of parentElement with the parsed htmlString. Very powerful but destructive, and prone to XSS if htmlString is from untrusted sources. Often used when replacing a large section of content.
 • parentElement.textContent = textString: Sets or returns the textual content of the specified node, effectively removing all child elements and replacing them with plain text.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° C-S Elements °°°
Cross-Site Scripting  is a web security vulnerability that allows an attacker to inject malicious client-side scripts into web pages viewed by other users. The attacker's script then executes in the victim's browser, within the context of the vulnerable website. 
This can lead to a variety of attacks, including:
 * Session hijacking: S
 * Defacement: Modifying the content of the web page.
 * Redirection: Redirecting the user to a malicious website.
 * Malware distribution: Tricking the user into downloading and installing malware.
 * Phishing: Presenting fake login forms to steal credentials.
The elements we discussed (radio buttons and checkboxes) aren't inherently XSS vulnerabilities themselves. The vulnerability arises when the values or labels associated with these elements, or how they are dynamically created and rendered, are directly influenced by untrusted user input without proper sanitization or encoding.
There are three main types of XSS attacks:
1. Reflected XSS (Non-Persistent XSS)
How it works: The malicious script is part of the HTTP request (e.g., in a URL parameter, form field) and is "reflected" immediately back in the HTTP response without being stored on the server. The attacker typically crafts a malicious URL and tricks a victim into clicking it.
How it could affect radio buttons/checkboxes:
If a website reflects user input directly into the value or label of a dynamically generated radio button or checkbox without proper encoding:
 * Vulnerable scenario: Imagine a search page where the search query is reflected back in a hidden input, or perhaps even used to pre-fill a checkbox label.
   <p>You searched for: <span id="queryDisplay">SEARCH_QUERY</span></p>
<input type="checkbox" id="search_result" name="result" value="SEARCH_QUERY">
<label for="search_result">Show result for: SEARCH_QUERY</label>

   If SEARCH_QUERY is taken directly from a URL parameter like ?q=<script>alert('XSS');</script>, and the server doesn't encode it, the script will execute.
 * Example Payload in URL parameter (Reflected):
   https://example.com/search?q=<script>alert(document.cookie)</script>
   If the server uses this q parameter to, say, set the value or label of a dynamically created checkbox:
   // Vulnerable JavaScript: Directly using URL parameter without sanitization
const urlParams = new URLSearchParams(window.location.search);
const userQuery = urlParams.get('q'); // Attacker controls this

const container = document.getElementById('myDynamicForm');
if (container) {
    // This is highly vulnerable!
    container.innerHTML = `<input type="checkbox" id="queryCB" name="q" value="${userQuery}">
                           <label for="queryCB">Result for: ${userQuery}</label>`;
}

   The innerHTML assignment will parse the injected <script> tag, leading to XSS.
2. Stored XSS (Persistent XSS)
How it works: The malicious script is injected into the web application, stored persistently on the server (e.g., in a database, file system), and then served to other users without proper sanitization when they access the vulnerable page. This is generally the most dangerous type of XSS because the attacker only needs to inject the payload once, and it will affect all subsequent users who view the compromised data.
How it could affect radio buttons/checkboxes:
If user-submitted data (e.g., a profile name, comment, product description, survey option) that can be later displayed as a radio button label or checkbox value is not sanitized before being stored and then rendered:
 * Vulnerable scenario: A forum where users can create custom poll options, or an e-commerce site where product features are entered by vendors.
   * User input (malicious): <script>alert('You\'ve been hacked!');</script>
   * This input is stored in the database.
   * Later, when another user views the poll/product, the server retrieves the malicious string from the database and inserts it directly into the HTML to form a radio button label or checkbox value:
     <input type="radio" id="pollOption1" name="poll" value="option1">
<label for="pollOption1"><script>alert('You\'ve been hacked!');</script></label>

   The script executes for every user who loads this page.
°°° DOM-based XSS (Type-0 XSS)
How it works: The XSS vulnerability lies entirely within the client-side JavaScript code. The malicious payload is executed as a result of manipulating the DOM environment in the victim's browser. The data typically comes from an attacker-controllable source (like document.URL, location.hash, document.referrer, localStorage, sessionStorage, document.cookie) and is then passed to a "sink" (a function or property that executes code, like innerHTML, document.write(), eval(), setTimeout(), location.href).

°°°How it could affect radio buttons/checkboxes:
If JavaScript code takes user-controlled input and uses it to dynamically build or modify HTML elements (including radio buttons and checkboxes) without proper sanitization, particularly using properties like innerHTML.
 ° Vulnerable scenario: A page whose content (e.g., a default selection for a radio button, or a pre-checked checkbox based on user preferences) is determined by reading a URL fragment (#).
   • Malicious URL: https://example.com/preferences#default_option=<img src=x onerror=alert('DOM%20XSS!')>
   ° Vulnerable JavaScript:
     // JavaScript on the preferences page
const fragment = window.location.hash.substring(1); // Gets 'default_option=<img src=x onerror=alert('DOM%20XSS!')>'
const parts = fragment.split('=');
const defaultOption = parts[1]; // Extracts the malicious payload

const container = document.getElementById('settings');
if (container) {
    // Highly vulnerable if defaultOption is not sanitized!
    // If the preference was to set a checkbox label:
    container.innerHTML += `<p>Your default preference:</p>
                            <input type="checkbox" id="prefCB" name="pref" value="default">
                            <label for="prefCB">${defaultOption}</label>`;
}

   When the page loads, the JavaScript reads the hash, inserts it directly into innerHTML, and the onerror event of the malformed <img> tag executes the script.
Specific Vulnerabilities with HTML input and label Elements
The core of these elements:
 ° Attribute Injection:
   
   ° value="something_safe" onerror="alert(1)" (for inputs with event handlers)
   ° value="something_safe"><img src=x onerror=alert(1)> (breaking out of the attribute)
   ° For type="checkbox" or type="radio", the value attribute itself isn't directly executed, but breaking out of it and injecting a new element is possible.
   ° Example for value attribute: <input type="checkbox" value="[USER_INPUT]">
     Payload: " onload=alert(1) src=x>
     Result: <input type="checkbox" value="" onload=alert(1) src=x> (if rendered inside an outer HTML element like a div that allows onload). Or simply breaking out to inject a new script: "><script>alert(1)</script>
 ° HTML Injection into Label/Text Content:
   If the text content of a <label> or other surrounding HTML (div, p, span) that contains the checkbox/radio button is created from unsanitized input.
   ° <label for="myid">USER_INPUT</label>
   ° Payload: <script>alert(1)</script>
   ° Result: <label for="myid"><script>alert(1)</script></label>
 
° Dynamic Creation with innerHTML (as shown in examples):
   This is the most common pitfall when dynamically creating elements. Using innerHTML with unsanitized user input is a direct path to XSS.
   // UNSAFE: If `userInput` comes from URL, database, etc. without sanitization
container.innerHTML = `<input type="checkbox" value="${userInput}"><label>${userInput}</label>`;

Mitigation and Prevention
The key to preventing XSS, regardless of the element type, is proper input validation, sanitization, and output encoding.
 • Sanitize Input:
   ° Validation: Ensure that input conforms to expected formats (e.g., only numbers for a quantity, specific characters for a name). Reject anything that doesn't match.
   ° Sanitization: Remove or escape potentially dangerous characters or HTML tags from user-supplied data before storing it (for Stored XSS) or before reflecting it (for Reflected XSS).
     ° For content that is only meant to be text, use element.textContent = untrustedData; instead of element.innerHTML = untrustedData;. textContent automatically escapes HTML entities.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°°Labels°°°
<label for="full_name">Your name</label>
<input type="text" id="full_name" name="name">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Implicit Label°°°
<label>Your name
  <input type="text" name="name">
</label>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Group Labels °°°
°°°To label the group, group all of the elements into a <fieldset>, with the <legend> providing the label for the group.°°°

°°°Example••
<fieldset>
  <legend>Who is your favorite student?</legend>
  <ul>
    <li>
      <label>
        <input type="radio" value="blendan" name="machine"> Blendan Smooth
      </label>
    </li>
    <li>
      <label>
        <input type="radio" value="hoover" name="machine"> Hoover Sukhdeep
      </label>
    </li>
    <li>
      <label>
        <input type="radio" value="toasty" name="machine"> Toasty McToastface
      </label>
    </li>
  </ul>
</fieldset>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Keyboards, Mics, Cameras°°°
°°°Function for Keyboard:
function focusOnInput(elementId) {
    const inputElement = document.getElementById(elementId);
    if (inputElement) {
        inputElement.focus();
        console.log(`Focused on input: ${elementId}`);
    } else {
        console.error(`Input element with ID '${elementId}' not found.`);
    }
}

// Example HTML structure:
/*
<input type="text" id="myTextInput" placeholder="Type here...">
<button onclick="focusOnInput('myTextInput')">Open Keyboard</button>
*/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Android Keyboards °°°
// Ensure compatibility across browsers
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
const SpeechRecognitionEvent = window.SpeechRecognitionEvent || window.webkitSpeechRecognitionEvent;

function startSpeechToText(outputElementId, micButtonId) {
    if (!SpeechRecognition) {
        alert('Speech Recognition not supported in this browser. Please use Chrome, Edge, or a modern browser.');
        return;
    }

    const outputElement = document.getElementById(outputElementId);
    const micButton = document.getElementById(micButtonId);

    const recognition = new SpeechRecognition();
    recognition.continuous = false; // Set to true for continuous listening
    recognition.lang = 'en-US'; // Set language
    recognition.interimResults = false; // Get final results only
    recognition.maxAlternatives = 1; // Get the most likely result

    if (micButton) {
        micButton.textContent = 'Speak Now...';
        micButton.disabled = true; // Disable button while listening
    }

    recognition.onresult = (event) => {
        const speechResult = event.results[0][0].transcript;
        if (outputElement) {
            outputElement.textContent = `You said: "${speechResult}"`;
            // Optionally, put the result into a text input
            // const targetInput = document.getElementById('myTextInput');
            // if (targetInput) targetInput.value = speechResult;
        }
        console.log('Speech result:', speechResult);
    };

    recognition.onend = () => {
        console.log('Speech recognition ended.');
        if (micButton) {
            micButton.textContent = 'Start Mic Input';
            micButton.disabled = false; // Re-enable button
        }
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (outputElement) {
            outputElement.textContent = `Error: ${event.error}`;
        }
        if (micButton) {
            micButton.textContent = 'Start Mic Input (Error)';
            micButton.disabled = false;
        }
        // Handle specific errors like "not-allowed" for mic permissions
        if (event.error === 'not-allowed') {
            alert('Microphone access denied. Please enable it in your browser settings.');
        }
    };

    // Start recognition
    recognition.start();
    console.log('Speech recognition started. Listening...');
}

// Example HTML structure:
/*
<input type="text" id="speechTextInput" placeholder="Speech input will go here">
<button id="micInputButton" onclick="startSpeechToText('speechTextInput', 'micInputButton')">Start Mic Input</button>
*/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° To Build the above 🔝 °°°
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Keyboard & Mic Interaction</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
        .input-group { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; }
        input[type="text"] { width: calc(100% - 22px); padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #speechResultDisplay { margin-top: 10px; font-weight: bold; color: #333; }
        .info { font-size: 0.9em; color: #666; margin-top: 10px; }
    </style>
</head>
<body>

    <h1>Interactive Web Input</h1>

    <div class="input-group">
        <h2>Text Input & Keyboard Focus</h2>
        <input type="text" id="myTextInput" placeholder="Tap here, or use the button below">
        <div class="info">
            <p>Tap the input field above to bring up the keyboard normally.</p>
            <p>On mobile, this button attempts to programmatically open the keyboard (may require user gesture).</p>
        </div>
        <button onclick="focusOnInput('myTextInput')">Programmatically Focus Input (Open Keyboard)</button>
    </div>

    <div class="input-group">
        <h2>Speech-to-Text Input (Microphone)</h2>
        <input type="text" id="speechTextInput" placeholder="Spoken text will appear here..." readonly>
        <div class="info">
            <p>Click "Start Mic Input" to allow browser to access your microphone and convert speech to text.</p>
            <p>Requires HTTPS. Browser will ask for microphone permission.</p>
        </div>
        <button id="micInputButton" onclick="startSpeechToText('speechTextInput', 'micInputButton')">Start Mic Input</button>
        <p id="speechResultDisplay"></p>
    </div>

    <script>
        // --- Keyboard Focus Function ---
        function focusOnInput(elementId) {
            const inputElement = document.getElementById(elementId);
            if (inputElement) {
                inputElement.focus();
                console.log(`Focused on input: ${elementId}`);
                // On mobile, this will typically bring up the software keyboard
            } else {
                console.error(`Input element with ID '${elementId}' not found.`);
            }
        }

        // --- Speech Recognition (Microphone) Function ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        // const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList; // Not strictly necessary for basic use
        // const SpeechRecognitionEvent = window.SpeechRecognitionEvent || window.webkitSpeechRecognitionEvent; // Not strictly necessary for basic use

        function startSpeechToText(outputElementId, micButtonId) {
            if (!SpeechRecognition) {
                alert('Speech Recognition not supported in this browser. Please use Chrome, Edge, or a modern browser over HTTPS.');
                return;
            }

            const outputElement = document.getElementById(outputElementId);
            const micButton = document.getElementById(micButtonId);

            const recognition = new SpeechRecognition();
            recognition.continuous = false; // false for single utterance, true for continuous
            recognition.lang = 'en-US'; // Set language
            recognition.interimResults = false; // true for partial results while speaking, false for final result only
            recognition.maxAlternatives = 1; // Get the most likely result

            if (micButton) {
                micButton.textContent = 'Listening...';
                micButton.disabled = true; // Disable button while listening
            }
            if (outputElement) {
                outputElement.value = ''; // Clear previous text
                document.getElementById('speechResultDisplay').textContent = 'Listening...';
            }


            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                if (outputElement) {
                    outputElement.value = speechResult; // Put into input field
                }
                document.getElementById('speechResultDisplay').textContent = `You said: "${speechResult}"`;
                console.log('Speech result:', speechResult);
            };

            recognition.onend = () => {
                console.log('Speech recognition ended.');
                if (micButton) {
                    micButton.textContent = 'Start Mic Input';
                    micButton.disabled = false; // Re-enable button
                }
                // If no result was obtained (e.g., user said nothing)
                if (outputElement && outputElement.value === '') {
                    document.getElementById('speechResultDisplay').textContent = 'No speech detected or recognized.';
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (outputElement) {
                    outputElement.value = `Error: ${event.error}`;
                }
                document.getElementById('speechResultDisplay').textContent = `Error: ${event.error}`;

                if (micButton) {
                    micButton.textContent = 'Start Mic Input (Error)';
                    micButton.disabled = false;
                }
                if (event.error === 'not-allowed') {
                    alert('Microphone access denied. Please enable it in your browser settings for this site.');
                } else if (event.error === 'no-speech') {
                     document.getElementById('speechResultDisplay').textContent = 'No speech detected. Try again.';
                }
            };

            // Start recognition
            recognition.start();
            console.log('Speech recognition started. Listening...');
        }
    </script>

</body>
</html>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°°Uploading°°°
The file input type <input type="file"> enables uploading files via forms.

°°For example:
accept="video/*, .gif" 
accepts any video files or animated gifs. Use 
"audio/*" for sound files, 
"video/*" for video files, and "image/*" for image files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Using Capture°°°
<label for="avatar">A recent photo of yourself:</label>
<input type="file" capture="user" accept="image/*" name="avatar" id="avatar">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°°Selectors that match Form Control°°°
:required 
:optional 
:default 
:enabled  
:disabled, 
:read-write 
:read-only 
:checked
:readonly
:contenteditable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

°°°When a user enters information into form controls, the CSS UI selectors {:valid, :invalid, :in-range,:out-of-range }
will turn on and off.

°° When a user exits a form control. Either the 
:user-invalid 
or 
:user-valid 
pseudo-class will match.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Anti-Pattern CSS °°°
form:invalid [type="submit"] {
  opacity: 50%;
  pointer-events: none;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Constraints °°°
when you include input types with constraints, such as email, number, url and date types, if the value is non-null (not empty) and the current value is not a valid email, number, URL, date or time, the :invalid CSS pseudo-class will be a match. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
°°° Validation Techniques °°°
When a number, date, or time value is below the minimum min set. Or above the maximum max set the control, 
:out-of-range, 
:invalid,
the user will then be informed of the 
valididityState.rangeUnderflow, validityState.rangeOverflow error. 

°°°If this value is out of step with the other step value, the control will be 
:out-of-range 
:invalid and there will be a validityState.stepMismatch error. 

°°°The minlength and maxlength attributes will alert the user of an error with the validityState.tooLong,
or
validityState.tooShort on submissions. The maxlength also will prevent each user from entering too many $# characters.

°°° If a strong or value is Required and empty, the default error message for validityState.valueMissingwill will appear.°°°

°°° formmethod="dialog" can be used to override Default Methods.°°°

°°° "formnovalidate" us essential to use to ensure everything works inside your Browser.°°°

°°° Include aria-label="close", to ensure Users can always close out of the Browser.°°°

°°°Default error messages can be customized with the validityState.setCustomValidity('message here') method. °°°

°•°

🚨 Note: Here is a link that offers solutions to help complete guides.
"https://web.dev/learn/forms/javascript#validation_with_javascript"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
🚨 Note: All of these resources, text, etc are just basic cheat guides to demonstrate Knowledge, and help anyone who needs. However to really gain full knowledge, it is required to do all the labs, readings, courses to achieve satisfaction. For my Courses, to be honest once created they will be unlike anything you have seen. My Style, My Teachings, My Rules.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~